# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

categorize_rcpp <- function() {
    .Call(`_fastcats_categorize_rcpp`)
}

#' @title Convert integers to strings as quickly as possible
#' @description Have tried R, \code{sprintf} with \CRANpkg{Rcpp} and C++
#'   standard library. Doesn't do bounds checking, but limited by length of
#'   integers.
#' @param x Vector of integers
#' @return Vector of characters
#' @keywords internal manip
#' @noRd
fastIntToStringRcpp <- function(x) {
    .Call(`_fastcats_fastIntToStringRcpp`, x)
}

#' @title Categorize data by list of code vectors, using matrix multiplication
#' @description The problem is that the matrices could be huge, as there are
#'   many potential codes (columns), in addition to potentially vast numbers of
#'   rows.
#' @details
#' Several ways of reducing the problem: firstly, as with existing code, we can
#' drop any codes from the map which are not anywhere in the source data. With
#' many rows, this will be less effective as the long tail becomes
#' apparent.
#' @section Sparse matrices:
#' Using sparse matrices is another solution. Building
#' the initial matrix may become a significant part of the calculation, but once
#' done, the solution could be a simple matrix multiplication, which is
#' potentially highly optimized (Eigen, BLAS, GPU, etc.)
#' @section Eigen:
#' Eigen has parallel (non-GPU) optimized sparse row-major * dense matrix. In a
#' medical example, Patient to diagnosis code matrix must be the row-major
#' sparse one, so the dense matrix is then the categorization mapping.
#' \url{https://eigen.tuxfamily.org/dox/TopicMultiThreading.html}
#' @keywords internal array algebra
#' @noRd
mat_mul_wide_rcpp <- function(data, map, id_name, code_names, validate) {
    .Call(`_fastcats_matMulWide`, data, map, id_name, code_names, validate)
}

#' @title Factor without sorting \CRANpkg{Rcpp} implementation
#' @description Requiring character vector inputs only, no argument checking.
#' @keywords internal manip
#' @noRd
factor_nosort_rcpp_worker <- function(x, levels, na_rm) {
    .Call(`_fastcats_factorNoSort`, x, levels, na_rm)
}

#' @title Re-generate a factor with new levels, without doing string matching
#' @description This is called by an R wrapper. There is an \code{na.rm}
#'   version, too. Some work simply to mirror behavior of \code{base::factor},
#'   e.g. when a level is not available, but NA level is available, NA is
#'   inserted into the integer vector, not an index to the NA level.
#' @keywords internal manip
#' @noRd
refactor_worker <- function(x, new_levels, exclude_na, validate) {
    .Call(`_fastcats_refactor`, x, new_levels, exclude_na, validate)
}

#' @describeIn refactor_worker Drop all \code{NA} values from levels and values
#' @keywords internal
#' @noRd
refactor_narm_worker <- function(x, new_levels, validate) {
    .Call(`_fastcats_refactor_narm`, x, new_levels, validate)
}

#' @title Check a factor structure is valid
#' @keywords internal
#' @noRd
factor_is_valid <- function(f) {
    .Call(`_fastcats_factorIsValid`, f)
}

